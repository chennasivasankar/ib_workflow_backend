from dataclasses import dataclass
from typing import List

from ib_users.interactors.storages.user_accounts_storage import \
    UserAccountWithProfileDTO


@dataclass
class InvalidUserDTO(UserAccountWithProfileDTO):
    reason: str


class UserPresenter:

    @staticmethod
    def get_user_details(user_id):
        from ib_users.storages import UserAccountsSQLStorage
        return UserAccountsSQLStorage().get_user_details(user_id)

    def bulk_create_accounts_and_profiles(
            self, users: List[UserAccountWithProfileDTO]):
        from ib_users.storages import UserAccountsSQLStorage

        invalid_users = self._validate_users(users)
        if invalid_users:
            return invalid_users

        UserAccountsSQLStorage().bulk_create_accounts_and_profiles(users)

    def get_user_details_for_usernames(self, usernames):
        from ib_users.storages import UserAccountsSQLStorage
        return UserAccountsSQLStorage().get_user_details_for_usernames(
            usernames=usernames
        )

    def _validate_users(self, users: List[UserAccountWithProfileDTO]):
        invalid_users = []
        existing_users = self._get_existing_users(users)
        invalid_format_users = self._get_invalid_format_users(users)

        invalid_users.extend(existing_users)
        invalid_users.extend(invalid_format_users)

        return invalid_users

    def _get_invalid_format_users(
            self, users: List[UserAccountWithProfileDTO]):
        from ib_users.validators import EmailValidator
        from django.core.exceptions import ValidationError

        invalid_format_users = []
        for user in users:
            try:
                EmailValidator.validate(user.email)
            except ValidationError as ve:
                invalid_format_users.append(
                    self._form_invalid_user_dto(user, ve.message))
            try:
                from ib_users.validators import PasswordValidator
                PasswordValidator.validate(user.password)
            except ValidationError as ve:
                invalid_format_users.append(
                    self._form_invalid_user_dto(user, ve.message))

            try:
                from ib_users.validators import UsernameValidator
                UsernameValidator.validate(user.password)
            except ValidationError as ve:
                invalid_format_users.append(
                    self._form_invalid_user_dto(user, ve.message))
            try:
                from ib_users.validators import UsernameValidator
                UsernameValidator.validate(user.phone_number)
            except ValidationError as ve:
                invalid_format_users.append(
                    self._form_invalid_user_dto(user, ve.message))

        return invalid_format_users

    def _get_existing_users(
            self, users: List[UserAccountWithProfileDTO]):
        phone_numbers = [x.phone_number for x in users]
        emails = [x.email for x in users]
        usernames = [x.username for x in users]

        from ib_users.models import UserAccount
        existing_phone_numbers = \
            list(UserAccount.objects.filter(phone_number__in=phone_numbers).
                 values_list('phone_number', flat=True))
        existing_emails = list(UserAccount.objects.filter(email__in=emails).
                               values_list('email', flat=True))
        existing_usernames = list(UserAccount.objects.filter(
            username__in=usernames).values_list('username', flat=True))

        return self._get_conflicting_users(users, existing_phone_numbers,
                                           existing_emails, existing_usernames)

    def _get_conflicting_users(self, users: List[UserAccountWithProfileDTO],
                               existing_phone_numbers,
                               existing_emails, existing_usernames):
        conflict_users = []

        for user in users:
            phone_number = user.phone_number
            email = user.email
            username = user.username

            if phone_number in existing_phone_numbers:
                reason = "Phone Number already exists"
                conflict_users.append(
                    self._form_invalid_user_dto(user, reason))

            if email in existing_emails:
                reason = "Email already exists"
                conflict_users.append(
                    self._form_invalid_user_dto(user, reason))

            if username in existing_usernames:
                reason = "username already exists"
                conflict_users.append(
                    self._form_invalid_user_dto(user, reason))

        return conflict_users

    @staticmethod
    def _form_invalid_user_dto(user: UserAccountWithProfileDTO, reason: str):
        user_dict = user.__dict__
        user_dict.update({'reason': reason})
        invalid_user = InvalidUserDTO(**user_dict)
        return invalid_user
