from ib_users.exceptions.custom_exception_constants import ExceptionMessages
from ib_users.exceptions.user_account_exceptions import InvalidUsername, \
    UsernameAlreadyExists, InvalidAction, UsernameDoesNotExist, \
    UserAccountAlreadyDeactivated, UserDoesNotExist, SocialAccountAlreadyTaken
from ib_users.interactors.logout.logout_in_devices import \
    LogoutInDevices
from ib_users.interactors.presenters.user_account_presenter import \
    UserAccountPresenter
from ib_users.interactors.storages import UserAccountsStorage
from ib_users.interactors.storages.user_social_accounts_storage import \
    UserSocialAccountsStorage
from ib_users.interactors.third_party.social_account import SocialAccount
from ib_users.validators.username_validator import UsernameValidator


class UserAccountInteractor:
    # TODO: check and update references, need to separate out to
    #  different files fro different apis
    def __init__(self, account_storage: UserAccountsStorage,
                 social_account_storage: UserSocialAccountsStorage):
        self.account_storage = account_storage
        self.social_account_storage = social_account_storage

    def change_username(self, current_username, new_username,
                        presenter: UserAccountPresenter):

        self._check_and_throw_exception_if_two_usernames_are_equal(
            current_username=current_username, new_username=new_username)

        self.check_if_username_is_valid(username=new_username)

        self._check_and_throw_exception_if_username_does_not_exist(
            username=current_username
        )
        self._check_and_throw_exception_if_username_exists(
            username=new_username
        )
        user_account_dto = self.account_storage.update_username(
            current_username=current_username,
            new_username=new_username
        )
        return presenter.get_user_account(
            user_account_dto=user_account_dto
        )

    def activate_user(self, user_id):
        self._check_and_throw_exception_if_user_does_not_exist(
            user_id=user_id
        )

        self._check_and_throw_exception_if_user_account_is_active(
            user_id=user_id)

        self.account_storage.activate_user(user_id=user_id)

    def link_social_account(self,
                            user_id: str,
                            social_account: SocialAccount,
                            **kwargs):
        social_access_token = kwargs["access_token"]
        self._check_and_throw_exception_if_user_does_not_exist(
            user_id=user_id
        )

        social_account.check_and_throw_exception_if_given_string_is_empty(
            string=social_access_token
        )

        # TODO: Add check if user already has social account
        # TODO: Add check if social account is already taken other user

        social_id = social_account.get_social_id(
            **kwargs
        )
        from django.db import IntegrityError
        try:
            self.social_account_storage.link_social_account(
                social_id=social_id,
                social_account_type=social_account.get_social_account_type(),
                user_id=user_id
            )
        except IntegrityError:
            raise SocialAccountAlreadyTaken(
                ExceptionMessages.SOCIAL_ACCOUNT_ALREADY_TAKEN,
            )

    def deactivate_user_account(
            self, user_id: str, logout_in_all_devices: LogoutInDevices
    ):
        self._check_and_throw_exception_if_user_does_not_exist(
            user_id=user_id
        )
        self._check_and_throw_exception_if_user_account_is_already_deactivated(
            user_id=user_id
        )
        self.account_storage.deactivate_user_account(user_id=user_id)
        logout_in_all_devices.logout_in_all_devices(user_id)

    def unlink_social_account(self, user_id: str,
                              social_account: SocialAccount):
        social_account_type = social_account.get_social_account_type()
        self.check_and_throw_exception_if_social_account_is_not_available(
            user_id, social_account_type
        )
        self.social_account_storage.unlink_social_account(user_id, social_account_type)

    def get_user_id_given_phone_number(
            self, phone_number: str, country_code: str) -> str:
        from ib_users.interactors.DTOs.common_dtos import PhoneNumberDTO

        phone_number_dto = PhoneNumberDTO(
            country_code=country_code, phone_number=phone_number
        )
        return self.account_storage.get_user_id_given_phone_number(
            phone_number_dto
        )

    def get_user_id_given_email(self, email: str) -> str:
        return self.account_storage.get_user_id_given_email(
            email
        )

    def _check_and_throw_exception_if_user_account_is_already_deactivated(
            self, user_id: str):
        is_user_account_deactivated = self.account_storage.is_user_account_deactivated(
            user_id=user_id)
        if is_user_account_deactivated:
            raise UserAccountAlreadyDeactivated(
                ExceptionMessages.USER_ACCOUNT_IS_ALREADY_DEACTIVATED
            )

    def check_and_throw_exception_if_social_account_is_not_available(
            self, user_id: str,
            social_account_type: str):
        if not self.social_account_storage.is_social_account_available(
                user_id, social_account_type):
            raise InvalidAction(
                ExceptionMessages.NO_SOCIAL_ACCOUNT_AVAILABLE.format(
                    social_account_type
                )
            )

    @staticmethod
    def check_if_username_is_valid(username):
        username_validator = UsernameValidator()
        username_validator.validate(value=username)
        pass

    def _check_and_throw_exception_if_user_does_not_exist(self, user_id: str):
        if not self.account_storage.is_user_id_exists(user_id=user_id):
            raise UserDoesNotExist(
                ExceptionMessages.USER_DOES_NOT_EXIST
            )

    def _check_and_throw_exception_if_username_exists(self, username):
        if self.account_storage.is_username_exists(username=username):
            raise UsernameAlreadyExists(
                ExceptionMessages.USERNAME_ALREADY_EXISTS
            )

    def _check_and_throw_exception_if_username_does_not_exist(self, username):
        if not self.account_storage.is_username_exists(username=username):
            raise UsernameDoesNotExist(
                ExceptionMessages.USERNAME_DOES_NOT_EXIST
            )

    @staticmethod
    def _check_and_throw_exception_if_two_usernames_are_equal(
            current_username, new_username):
        if current_username == new_username:
            raise InvalidUsername(ExceptionMessages.GIVEN_USERNAME_IS_SAME)

    def _check_and_throw_exception_if_user_account_is_active(self, user_id):
        if self.account_storage.is_user_account_active(user_id=user_id):
            raise InvalidAction(
                ExceptionMessages.USER_ACCOUNT_IS_ALREADY_ACTIVE
            )
