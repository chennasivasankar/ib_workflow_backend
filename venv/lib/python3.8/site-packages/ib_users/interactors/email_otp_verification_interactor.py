from ib_users.interactors.storages.otp_blacklist_storage import \
    OTPBlacklistStorage
from ib_users.interactors.storages.otp_verification_storage import \
    OTPVerificationStorage
from ib_users.interactors.third_party.email_sender import EmailSender
from ib_users.validators.email_validator import EmailValidator
from ib_users.constants.otp_verification_constants import OTPStatus, \
    OTP_EXPIRY_TIME_IN_SEC, VerificationType
from ib_users.exceptions.otp_verification_exceptions import ExceptionMessage, \
    MaxRetriesExceededException, OTPExpiredException, \
    InvalidOTPException
from ib_users.interactors.base_otp_verification_interactor import \
    BaseOTPVerificationInteractor
from ib_users.validators.otp_validator import validate_otp


class EmailOTPVerificationInteractor(BaseOTPVerificationInteractor):
    def __init__(self,
                 storage: OTPVerificationStorage,
                 otp_blacklist_storage: OTPBlacklistStorage,
                 verification_type: VerificationType):
        super().__init__(
            storage=storage,
            otp_blacklist_storage=otp_blacklist_storage,
            verification_type=verification_type
        )

    def verify_email(self, email: str,
                     email_validator: EmailValidator,
                     email_sender: EmailSender):
        email_validator.validate(email)
        self._check_and_throw_exception_if_email_is_blacklisted(
            email=email
        )
        otp = self._create_or_update_email_otp_verification_record(email=email)
        email_sender.send_otp(
            email=email,
            otp=otp
        )

    def validate_otp_to_verify_email(self, email: str,
                                     otp_to_be_verified: str):

        validate_otp(otp_to_be_verified)
        self._check_and_throw_exception_if_max_retries_count_exceeded_for_email(
            email=email,
            verification_type=self.verification_type
        )
        self._check_and_throw_exception_if_otp_is_not_matched_for_email(
            email=email,
            otp_to_be_verified=otp_to_be_verified,
            verification_type=self.verification_type
        )
        self._check_and_throw_exception_if_email_otp_is_expired(
            email=email
        )
        self.storage.reset_retries_count_for_email(
            email=email,
            verification_type=self.verification_type
        )
        return True

    def _create_or_update_email_otp_verification_record(self, email: str):
        is_email_whitelisted = self.storage.is_email_whitelisted(email=email)
        if is_email_whitelisted:
            get_otp_details_dto = self.storage.get_configured_otp_for_email(
                email=email
            )
            otp = get_otp_details_dto.otp
        else:
            otp_status = self.storage.get_otp_status_by_email(
                email=email,
                verification_type=self.verification_type
            )
            otp = self._get_otp_from_create_or_update_email_otp_verification_record(
                email=email,
                otp_status=otp_status
            )
        return otp

    def _get_otp_from_create_or_update_email_otp_verification_record(self,
                                                        email: str,
                                                        otp_status: OTPStatus):
        new_otp = BaseOTPVerificationInteractor._generate_otp()
        if otp_status == OTPStatus.NOT_REQUESTED:
            self.storage.create_otp_verification_for_email(
                email=email,
                otp=new_otp,
                expiry_time_in_sec=OTP_EXPIRY_TIME_IN_SEC,
                verification_type=self.verification_type
            )
            return new_otp
        elif otp_status == OTPStatus.EXPIRED:
            self.storage.update_otp_details_by_email(
                email=email,
                otp=new_otp,
                expiry_time_in_sec=OTP_EXPIRY_TIME_IN_SEC,
                verification_type=self.verification_type
            )
            return new_otp
        else:
            otp_details = self.storage.get_otp_details_by_email(
                email=email,
                verification_type=self.verification_type
            )
            old_otp = otp_details.otp
            self.storage.update_otp_details_by_email(
                email=email,
                otp=old_otp,
                expiry_time_in_sec=OTP_EXPIRY_TIME_IN_SEC,
                verification_type=self.verification_type
            )
            return old_otp

    def _check_and_throw_exception_if_max_retries_count_exceeded_for_email(
            self, email: str, verification_type: VerificationType):
        is_exceeded = self.storage.is_exceeded_max_retries_count_for_email(
            email=email,
            verification_type=verification_type
        )
        if is_exceeded:
            raise MaxRetriesExceededException(
                ExceptionMessage.RETRY_AFTER_X_DURATION
            )

    def _check_and_throw_exception_if_email_otp_is_expired(self, email: str):
        otp_status = self.storage.get_otp_status_by_email(
            email=email,
            verification_type=self.verification_type
        )
        if otp_status == OTPStatus.EXPIRED:
            raise OTPExpiredException(
                ExceptionMessage.OTP_IS_EXPIRED
            )

    def _check_and_throw_exception_if_otp_is_not_matched_for_email(
                                        self,
                                        email: str, otp_to_be_verified: str,
                                        verification_type: VerificationType):
        is_otp_matched = self.storage.is_otp_matched_for_email(
            email=email,
            otp_to_be_verified=otp_to_be_verified,
            verification_type=verification_type
        )
        if not is_otp_matched:
            self.storage.increase_retries_count_by_one_for_email(
                email=email,
                verification_type=verification_type
            )
            raise InvalidOTPException(ExceptionMessage.ENTER_A_VALID_OTP)
