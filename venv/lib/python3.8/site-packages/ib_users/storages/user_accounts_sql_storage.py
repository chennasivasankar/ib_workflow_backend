from ib_users.exceptions.custom_exception_constants import \
    NOT_REGISTERED_USER, INCORRECT_PASSWORD
from ib_users.exceptions.registration_exceptions import \
    AccountWithThisEmailAlreadyExistsException, \
    AccountWithThisPhoneNumberAlreadyExistsException, \
    UsernameAlreadyExistsException
from ib_users.interactors.exceptions.user_credentials_exceptions import \
    AccountWithUsernameDoesntExistException, CurrentPasswordMismatchException, \
    AccountWithEmailDoesntExistException, \
    AccountWithPhoneNumberDoesntExistException, InvalidUserIdException
from ib_users.interactors.registration.DTOs.registration_dtos import \
    CreateAccountWithPhoneNumberDTO, CreateAccountWithEmailDTO
from ib_users.interactors.storages.user_accounts_storage import \
    UserAccountsStorage, PhoneNumberAndPasswordDTO, UserNameAndPasswordDTO, \
    EmailAndPasswordDTO, PhoneNumberDTO, UserEmailAndPhoneNumberDTO, \
    UserAccountDTO
from ib_users.models import UserAccount
from ib_users.storages.user_account_sql_base_storage import \
    UserAccountSQLBaseStorage
from ib_users.validators.base_validator import CustomException


class UserAccountsSQLStorage(UserAccountSQLBaseStorage, UserAccountsStorage):

    def link_email_to_user(self, user_id: str, email: str):
        try:
            user_account_obj = UserAccount.objects.filter(user_id=user_id). \
                update(email=email)
            return user_account_obj
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    def link_phone_number_to_user(
            self, user_id: str, phone_number_dto: PhoneNumberDTO):
        try:
            user_account_obj = UserAccount.objects.filter(user_id=user_id). \
                update(phone_number=phone_number_dto.phone_number,
                       country_code=phone_number_dto.country_code)
            return user_account_obj
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    def get_user_details_to_send_otp_given_phone_number(
            self, phone_number: PhoneNumberDTO) -> UserEmailAndPhoneNumberDTO:
        try:
            user_account_obj = UserAccount.objects.get(
                phone_number=phone_number.phone_number,
                country_code=phone_number.country_code)

            return self._get_user_email_and_phone_number_from_user_account(
                user_account_obj)
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    def get_user_details_to_send_otp_given_email(
            self, email: str) -> UserEmailAndPhoneNumberDTO:
        try:
            user_account_obj = UserAccount.objects.get(email=email)
            return self._get_user_email_and_phone_number_from_user_account(
                user_account_obj)
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    def get_user_id_given_phone_number(self, phone_number_dto: PhoneNumberDTO):
        user_account = self. \
            _get_user_account_given_phone_number(phone_number_dto)
        return str(user_account.user_id)

    def get_user_id_given_email(self, email: str):
        user_account = self._get_user_account_given_email(email)
        return str(user_account.user_id)

    def get_user_id_given_username_and_password(
            self, username_login: UserNameAndPasswordDTO):

        user_account = self. \
            _get_user_account_given_username(username_login.username)

        self._check_password_for_given_user_account(
            user_account,
            username_login.password)
        return str(user_account.user_id)

    def get_user_id_given_email_and_password(
            self, email_login: EmailAndPasswordDTO):

        user_account = self. \
            _get_user_account_given_email(email_login.email)

        self._check_password_for_given_user_account(
            user_account,
            email_login.password)
        return str(user_account.user_id)

    def get_user_id_given_phone_number_and_password(
            self, phone_number_login: PhoneNumberAndPasswordDTO):

        user_account = self. \
            _get_user_account_given_phone_number(
            phone_number_login.phone_number_DTO)

        self._check_password_for_given_user_account(
            user_account, phone_number_login.password)

        return str(user_account.user_id)

    def create_account_with_username(self, username: str, password: str) -> \
            str:
        import uuid
        registered_user_account = UserAccount(username=username)
        registered_user_account.user_id = uuid.uuid4()
        registered_user_account.set_password(password)
        registered_user_account.save()
        return str(registered_user_account.user_id)

    def create_account_with_email(
            self, create_account_dto: CreateAccountWithEmailDTO) -> str:
        import uuid
        registered_user_account = UserAccount(email=create_account_dto.email)
        registered_user_account.user_id = uuid.uuid4()

        if create_account_dto.username:
            registered_user_account.username = create_account_dto.username

        registered_user_account.set_password(create_account_dto.password)
        registered_user_account.save()
        return str(registered_user_account.user_id)

    def create_account_with_phone_number(
            self, create_account_dto: CreateAccountWithPhoneNumberDTO) -> str:
        import uuid
        registered_user_account = UserAccount(
            phone_number=create_account_dto.phone_number,
            country_code=create_account_dto.country_code
        )
        registered_user_account.user_id = uuid.uuid4()
        if create_account_dto.username:
            registered_user_account.username = create_account_dto.username

        registered_user_account.set_password(create_account_dto.password)
        registered_user_account.save()
        return str(registered_user_account.user_id)

    def check_user_exists_with_username(self, username: str):
        if UserAccount.objects.filter(username=username).exists():
            raise UsernameAlreadyExistsException

    def check_user_exists_with_email(self, email: str):
        if UserAccount.objects.filter(email=email).exists():
            raise AccountWithThisEmailAlreadyExistsException

    def check_user_exists_with_phone_number(
            self, phone_number_dto: PhoneNumberDTO):
        if UserAccount.objects.filter(
                phone_number=phone_number_dto.phone_number,
                country_code=phone_number_dto.country_code).exists():
            raise AccountWithThisPhoneNumberAlreadyExistsException

    def update_username(self, current_username: str, new_username: str):
        updating_user = UserAccount.objects.get(username=current_username)
        updating_user.username = new_username
        updating_user.save()

        return UserAccountDTO(
            user_id=str(updating_user.user_id),
            username=updating_user.username
        )

    def is_username_exists(self, username: str) -> bool:
        return UserAccount.objects.filter(username=username).exists()

    def is_user_account_deactivated(self, user_id: str) -> bool:
        return not self.is_user_account_active(user_id)

    def activate_user(self, user_id: str):
        UserAccount.objects.filter(user_id=user_id).update(is_active=True)

    def deactivate_user_account(self, user_id: str):
        UserAccount.objects.filter(user_id=user_id).update(is_active=False)

    def is_user_id_exists(self, user_id: str) -> bool:
        return UserAccount.objects.filter(user_id=user_id).exists()

    @staticmethod
    def _get_user_email_and_phone_number_from_user_account(
            user_account: UserAccount):

        phone_number_dto = PhoneNumberDTO(user_account.country_code,
                                          user_account.phone_number)
        user_email_and_phone_number_dto = UserEmailAndPhoneNumberDTO(
            str(user_account.user_id),
            user_account.email,
            phone_number_dto)
        return user_email_and_phone_number_dto

    @staticmethod
    def _get_user_account_given_username(username: str):
        try:
            user_account_obj = UserAccount.objects.get(username=username)
            return user_account_obj
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    @staticmethod
    def _get_user_account_given_email(email: str):
        try:
            user_account_obj = UserAccount.objects.get(email=email)
            return user_account_obj
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    @staticmethod
    def _get_user_account_given_phone_number(phone_number_dto: PhoneNumberDTO):
        try:
            user_account_obj = UserAccount.objects.get(
                phone_number=phone_number_dto.phone_number,
                country_code=phone_number_dto.country_code)

            return user_account_obj
        except UserAccount.DoesNotExist:
            raise CustomException.from_exception_message_DTO(
                NOT_REGISTERED_USER)

    @staticmethod
    def _check_password_for_given_user_account(user_account: UserAccount,
                                               password):
        is_correct_password = user_account.check_password(password)
        if not is_correct_password:
            raise CustomException.from_exception_message_DTO(
                INCORRECT_PASSWORD)

    def update_user_password(self, user_id: str, new_password: str):
        user_account = UserAccountsSQLStorage._validate_and_get_user_account(
            user_id=user_id)
        user_account.set_password(new_password)
        user_account.is_password_reset = True
        user_account.save()

    def check_current_password_matches(self, user_id: str,
                                       current_password: str):
        user_account = UserAccountsSQLStorage._validate_and_get_user_account(
            user_id=user_id)
        is_match = user_account.check_password(current_password)
        if not is_match:
            raise CurrentPasswordMismatchException

    def is_default_password_changed(self, user_id: str) -> bool:
        user_account = UserAccountsSQLStorage._validate_and_get_user_account(
            user_id)
        return user_account.is_password_reset

    def get_user_given_username(self, username: str) -> UserAccount:
        try:
            user_account = UserAccount.objects.get(username=username)
            return user_account
        except UserAccount.DoesNotExist:
            raise AccountWithUsernameDoesntExistException

    def get_user_given_email(self, email: str) -> UserAccount:
        try:
            user_account = UserAccount.objects.get(email=email)
            return user_account
        except UserAccount.DoesNotExist:
            raise AccountWithEmailDoesntExistException

    def get_existing_user_id_given_email(self, email:str):
        try:
            user_account = UserAccount.objects.get(email=email)
            return user_account.user_id
        except UserAccount.DoesNotExist:
            raise AccountWithEmailDoesntExistException

    def get_user_given_phone_number(
            self, phone_number_dto: PhoneNumberDTO) -> UserAccount:
        try:
            user_account = UserAccount.objects.get(
                phone_number=phone_number_dto.phone_number,
                country_code=phone_number_dto.country_code)
            return user_account
        except UserAccount.DoesNotExist:
            raise AccountWithPhoneNumberDoesntExistException

    def get_user_details_to_send_otp_given_username(self,
                                                    username: str) -> UserEmailAndPhoneNumberDTO:
        try:
            user_account = UserAccount.objects.get(username=username)
            user_contact_details = UserEmailAndPhoneNumberDTO(
                user_id=user_account.user_id,
                phone_number=PhoneNumberDTO(user_account.phone_number,
                                            user_account.country_code),
                email=user_account.email)
            return user_contact_details
        except UserAccount.DoesNotExist:
            raise AccountWithUsernameDoesntExistException

    @staticmethod
    def _validate_and_get_user_account(user_id: str) -> UserAccount:
        try:
            return UserAccount.objects.get(user_id=user_id)
        except UserAccount.DoesNotExist:
            raise InvalidUserIdException

    def get_user_email(self, user_id) -> str:
        ua = UserAccount.objects.get(user_id=user_id)
        return ua.email

    def get_user_phone_number(self, user_id) -> str:
        ua = UserAccount.objects.get(user_id=user_id)
        return ua.phone_number

    def get_user_account_details(self, user_id: str) -> UserAccountDTO:
        ua = UserAccount.objects.get(user_id=user_id)
        return UserAccountDTO(username=ua.username,
                              phone_number=ua.phone_number,
                              email=ua.email,
                              country_code=ua.country_code,
                              user_id=ua.user_id)

    def update_user_phone_number(self, user_id, phone_number, country_code):
        ua = UserAccount.objects.get(user_id=user_id)
        ua.phone_number = phone_number
        ua.country_code = country_code
        ua.save()

    def update_email(self, user_id, email):
        ua = UserAccount.objects.get(user_id=user_id)
        ua.email = email
        ua.save()

    def update_user_active_status(self, user_id: str, is_active: bool):
        UserAccount.objects.filter(user_id=user_id).update(
            is_active=is_active
        )
