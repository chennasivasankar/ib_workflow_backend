from uuid import uuid4

from django_swagger_utils.drf_server.exceptions import BadRequest

from ib_users.constants.res_status_constants import ResStatusConstants
from ib_users.constants.user_account_constants import SocialAccountProviderType
from ib_users.exceptions.custom_exception_constants import ExceptionConstants
from ib_users.exceptions.registration_exceptions import \
    AccountWithSocialDetailsAlreadyExistsException
from ib_users.interactors.presenters.registration_presenter import \
    RegistrationPresenter


class RegistrationJSONPresenter(RegistrationPresenter):
    def get_user_id(self, user_uuid: uuid4)-> dict:
        return {"user_id": str(user_uuid)}

    @staticmethod
    def handle_social_account_already_exists(
            raised_exception: AccountWithSocialDetailsAlreadyExistsException):
        message = None
        res_status = None

        if raised_exception.social_provider == \
                SocialAccountProviderType.FACEBOOK.value:
            message = ExceptionConstants.ACCOUNT_ALREADY_EXISTS_WITH_THIS_FB_DETAILS
            res_status = ResStatusConstants.FB_ACCOUNT_ALREADY_USED
        elif raised_exception.social_provider == \
                SocialAccountProviderType.TWITTER.value:
            message = ExceptionConstants.ACCOUNT_ALREADY_EXISTS_WITH_THIS_TWITTER_DETAILS
            res_status = ResStatusConstants.TWITTER_ACCOUNT_ALREADY_USED

        elif raised_exception.social_provider == \
                SocialAccountProviderType.GOOGLE.value:
            message = ExceptionConstants.ACCOUNT_ALREADY_EXISTS_WITH_THIS_GOOGLE_DETAILS
            res_status = ResStatusConstants.GOOGLE_ACCOUNT_ALREADY_USED

        raise BadRequest(message=message, res_status=res_status)
