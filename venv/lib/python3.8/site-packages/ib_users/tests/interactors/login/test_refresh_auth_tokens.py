import pytest
from mock import create_autospec

from ib_users.exceptions.custom_exception_constants import \
    INVALID_REFRESH_TOKEN, EXPIRED_REFRESH_TOKEN, \
    ExceptionMessageDTO, USER_ACCOUNT_IS_DEACTIVATED
from ib_users.interactors.presenters import UserLoginPresenter
from ib_users.interactors.storages import UserAccountsStorage
from ib_users.interactors.storages.user_login_device_details_storage import \
    UserLoginDeviceDetailsStorage
from ib_users.interactors.third_party.user_tokens_generator import \
    UserAuthTokensGenerator, UserAuthTokensDTO
from ib_users.utils.tests_utils import TestsUtils
from ib_users.validators.base_validator import CustomException


# TODO: What to give input
@pytest.mark.parametrize("refresh_token, exception_msg",
                         [("", INVALID_REFRESH_TOKEN),
                          ("a@bc", INVALID_REFRESH_TOKEN),
                          (
                                  "dajsdqwQR@#RK@#RKKCSDSKL@#KRMCZ:LXMCZ:CM:MFLszMC:XZ?c",
                                  EXPIRED_REFRESH_TOKEN),
                          ("3010@gmail.l", INVALID_REFRESH_TOKEN)])
def test_malformed_or_expired_refresh_token(refresh_token: str,
                                            exception_msg: ExceptionMessageDTO):
    from ib_users.interactors import RefreshAuthTokens

    token_generator_mock = create_autospec(UserAuthTokensGenerator)
    token_generator_mock.get_updated_user_auth_tokens.side_effect = \
        CustomException.from_exception_message_DTO(exception_msg)

    presenter_mock = create_autospec(UserLoginPresenter)
    storage_mock = create_autospec(UserLoginDeviceDetailsStorage)
    accounts_storage_mock = create_autospec(UserAccountsStorage)

    refresh_login_tokens = RefreshAuthTokens(
        login_token_generator=token_generator_mock,
        presenter=presenter_mock,
        storage=storage_mock,
        accounts_storage=accounts_storage_mock
    )

    with pytest.raises(CustomException) as invalid_refresh_token:
        refresh_login_tokens.refresh_tokens(refresh_token=refresh_token,
                                            access_token="access_token")

    token_generator_mock.get_updated_user_auth_tokens.assert_called_once()
    TestsUtils.assert_custom_exception(exception_msg, invalid_refresh_token)


# TODO: What to give input
@pytest.mark.parametrize("refresh_token",
                         ["",
                          "a@bc",
                          "dajsdqwQR@#RK@#RKKCSDSKL@#KRMCZ:LXMCZ:CM:MFLszMC:XZ?c",
                          "3010@gmail.l"])
def test_refresh_tokens_with_valid_refresh_token_input(refresh_token: str):
    from ib_users.interactors import RefreshAuthTokens
    import datetime

    token_generator_mock = create_autospec(UserAuthTokensGenerator)
    presenter_mock = create_autospec(UserLoginPresenter)
    storage_mock = create_autospec(UserLoginDeviceDetailsStorage)
    accounts_storage_mock = create_autospec(UserAccountsStorage)

    refresh_login_tokens = RefreshAuthTokens(
        login_token_generator=token_generator_mock,
        presenter=presenter_mock,
        storage=storage_mock,
        accounts_storage=accounts_storage_mock
    )

    old_access_token = "access_token"
    new_auth_tokens_dto = UserAuthTokensDTO("user_id",
                                            "new_access_token",
                                            "new_refresh_token",
                                            datetime.datetime.now())
    token_generator_mock.get_updated_user_auth_tokens.return_value = new_auth_tokens_dto
    refresh_login_tokens.refresh_tokens(
        refresh_token=refresh_token,
        access_token=old_access_token)

    token_generator_mock.get_updated_user_auth_tokens.assert_called_once()
    presenter_mock.get_user_login_response.assert_called_once()
    storage_mock.update_access_token_in_access_token_and_device_id_map.assert_called_once_with(
        old_access_token,
        new_auth_tokens_dto.access_token)


@pytest.mark.parametrize("refresh_token",
                         ["",
                          "a@bc",
                          "dajsdqwQR@#RK@#RKKCSDSKL@#KRMCZ:LXMCZ:CM:MFLszMC:XZ?c",
                          "3010@gmail.l"])
def test_refresh_tokens_with_inactive_user(refresh_token: str):
    from ib_users.interactors import RefreshAuthTokens
    import datetime

    token_generator_mock = create_autospec(UserAuthTokensGenerator)
    presenter_mock = create_autospec(UserLoginPresenter)
    storage_mock = create_autospec(UserLoginDeviceDetailsStorage)
    accounts_storage_mock = create_autospec(UserAccountsStorage)

    accounts_storage_mock.is_user_account_active.return_value = False

    refresh_login_tokens = RefreshAuthTokens(
        login_token_generator=token_generator_mock,
        presenter=presenter_mock,
        storage=storage_mock,
        accounts_storage=accounts_storage_mock
    )

    old_access_token = "access_token"
    new_auth_tokens_dto = UserAuthTokensDTO("user_id",
                                            "new_access_token",
                                            "new_refresh_token",
                                            datetime.datetime.now())
    token_generator_mock.get_updated_user_auth_tokens.return_value = new_auth_tokens_dto

    with pytest.raises(CustomException) as err:
        refresh_login_tokens.refresh_tokens(
            refresh_token=refresh_token,
            access_token=old_access_token)
        assert err.value.message == USER_ACCOUNT_IS_DEACTIVATED.message
        assert err.value.res_status == USER_ACCOUNT_IS_DEACTIVATED.code
