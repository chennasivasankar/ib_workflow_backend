import pytest
from mock import create_autospec

from ib_users.constants.otp_verification_constants import OTPStatus
from ib_users.exceptions.otp_verification_exceptions import ExceptionMessage, \
    OTPExpiredException, InvalidOTPException, MaxRetriesExceededException
from ib_users.constants.otp_verification_constants import VerificationType
from ib_users.interactors.phone_number_otp_verification_interactor import \
    PhoneNumberOTPVerificationInteractor
from ib_users.interactors.storages.otp_blacklist_storage import \
    OTPBlacklistStorage


class TestValidateOTPToVerifyPhoneNumber:
    @pytest.fixture
    def setup(self):
        from ib_users.interactors.storages.otp_verification_storage import \
            OTPVerificationStorage

        from ib_users.utils.dtos import PhoneNumberDTO

        otp_verification_storage_mock = create_autospec(OTPVerificationStorage)
        otp_blacklist_storage_mock = create_autospec(OTPBlacklistStorage)
        phone_number_dto = PhoneNumberDTO(
            country_code="+91",
            phone_number="9866123399"
        )

        return otp_verification_storage_mock, phone_number_dto, \
               otp_blacklist_storage_mock

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_phone_number(self, setup, verification_type_mock):
        otp_verification_storage_mock, phone_number_dto, \
        otp_blacklist_storage_mock = setup

        phone_number_otp_verification_interactor = \
            PhoneNumberOTPVerificationInteractor(
                storage=otp_verification_storage_mock,
                otp_blacklist_storage=otp_blacklist_storage_mock,
                verification_type=verification_type_mock
            )

        otp_to_be_verified = "123456"
        otp_verification_storage_mock.is_exceeded_max_retries_count.\
            return_value = False

        is_verified = phone_number_otp_verification_interactor.\
            validate_otp_to_verify_phone_number(
                phone_number_dto=phone_number_dto,
                otp_to_be_verified=otp_to_be_verified
            )

        otp_verification_storage_mock.is_otp_matched.assert_called_once_with(
            phone_number_dto=phone_number_dto,
            otp_to_be_verified=otp_to_be_verified,
            verification_type=verification_type_mock
        )

        otp_verification_storage_mock.get_otp_status.assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
        )

        otp_verification_storage_mock.is_exceeded_max_retries_count.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
            )

        otp_verification_storage_mock.reset_retries_count.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
            )

        assert is_verified

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_phone_number_when_otp_expired(self, setup,
                                    verification_type_mock: VerificationType):
        otp_verification_storage_mock, phone_number_dto, \
        otp_blacklist_storage_mock = setup

        phone_number_otp_verification_interactor = \
            PhoneNumberOTPVerificationInteractor(
                storage=otp_verification_storage_mock,
                otp_blacklist_storage=otp_blacklist_storage_mock,
                verification_type=verification_type_mock
            )
        otp_to_be_verified = "123456"
        otp_verification_storage_mock.is_exceeded_max_retries_count. \
            return_value = False
        otp_verification_storage_mock.get_otp_status.return_value = \
            OTPStatus.EXPIRED

        with pytest.raises(OTPExpiredException) as e:
            phone_number_otp_verification_interactor.\
                validate_otp_to_verify_phone_number(
                    phone_number_dto=phone_number_dto,
                    otp_to_be_verified=otp_to_be_verified
                )

        assert ExceptionMessage.OTP_IS_EXPIRED in str(e.value)

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_phone_number_when_otp_is_invalid(self, setup, verification_type_mock):
        otp_verification_storage_mock, phone_number_dto, \
        otp_blacklist_storage_mock = setup

        phone_number_otp_verification_interactor = \
            PhoneNumberOTPVerificationInteractor(
                storage=otp_verification_storage_mock,
                otp_blacklist_storage=otp_blacklist_storage_mock,
                verification_type=verification_type_mock
            )
        otp_to_be_verified = "123456"
        otp_verification_storage_mock.is_exceeded_max_retries_count. \
            return_value = False
        otp_verification_storage_mock.is_otp_matched.return_value = False

        with pytest.raises(InvalidOTPException) as e:
            phone_number_otp_verification_interactor.\
                validate_otp_to_verify_phone_number(
                    phone_number_dto=phone_number_dto,
                    otp_to_be_verified=otp_to_be_verified
                )
        assert ExceptionMessage.ENTER_A_VALID_OTP in str(e.value)
        otp_verification_storage_mock.increase_retries_count_by_one. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
            )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_phone_number_when_max_retries_exceeded(self, setup, verification_type_mock):
        otp_verification_storage_mock, phone_number_dto, \
        otp_blacklist_storage_mock = setup

        phone_number_otp_verification_interactor = \
            PhoneNumberOTPVerificationInteractor(
                storage=otp_verification_storage_mock,
                otp_blacklist_storage=otp_blacklist_storage_mock,
                verification_type=verification_type_mock
            )

        otp_to_be_verified = "123456"
        otp_verification_storage_mock.is_exceeded_max_retries_count. \
            return_value = True
        otp_verification_storage_mock.is_otp_matched.return_value = True

        with pytest.raises(MaxRetriesExceededException) as e:
            phone_number_otp_verification_interactor.\
                validate_otp_to_verify_phone_number(
                    phone_number_dto=phone_number_dto,
                    otp_to_be_verified=otp_to_be_verified
                )
        assert ExceptionMessage.RETRY_AFTER_X_DURATION in str(e.value)

        otp_verification_storage_mock.is_exceeded_max_retries_count.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto,
                verification_type=verification_type_mock
            )

    @pytest.mark.parametrize('otp_to_be_verified,exception_message', [
        ("   ",  ExceptionMessage.OTP_IS_EMPTY),
        ("123", ExceptionMessage.OTP_SHOULD_CONTAIN_X_DIGITS),
        ("abc123", ExceptionMessage.OTP_SHOULD_CONTAIN_ONLY_NUMBERS)
    ])
    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    def test_verify_phone_number_when_otp_is_invalid(self, setup,
                                otp_to_be_verified: str, exception_message: str,
                                verification_type_mock: VerificationType):
        otp_verification_storage_mock, phone_number_dto, \
        otp_blacklist_storage_mock = setup

        phone_number_otp_verification_interactor = \
            PhoneNumberOTPVerificationInteractor(
                storage=otp_verification_storage_mock,
                otp_blacklist_storage=otp_blacklist_storage_mock,
                verification_type=verification_type_mock
            )

        with pytest.raises(InvalidOTPException) as e:
            phone_number_otp_verification_interactor.\
                validate_otp_to_verify_phone_number(
                    phone_number_dto=phone_number_dto,
                    otp_to_be_verified=otp_to_be_verified
                )

        assert exception_message in str(e.value)