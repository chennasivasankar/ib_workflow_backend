import pytest
from mock import create_autospec

from ib_users.constants.otp_verification_constants import OTPStatus, \
    OTP_EXPIRY_TIME_IN_SEC, SendOTPThrough
from ib_users.exceptions.otp_verification_exceptions import ExceptionMessage, \
    PhoneNumberIsBlackListedException, EmailIsBlackListedException
from ib_users.interactors.base_otp_verification_interactor import \
    BaseOTPVerificationInteractor
from ib_users.interactors.storages.otp_blacklist_storage import \
    OTPBlacklistStorage
from ib_users.interactors.third_party.call_service import CallService
from ib_users.interactors.third_party.email_sender import EmailSender
from ib_users.interactors.third_party.phone_number_validator import \
    PhoneNumberValidator
from ib_users.interactors.third_party.sms_sender import SMSSender
from ib_users.interactors.storages.otp_verification_storage import \
    GetOTPDetailsDTO
from ib_users.interactors.user_otp_verification_interactor import \
    UserOTPVerificationInteractor
from ib_users.utils.dtos import PhoneNumberDTO
from ib_users.constants.otp_verification_constants import VerificationType
from ib_users.validators.email_validator import EmailValidator


class TestVerifyUser:

    @ pytest.fixture
    def setup(self):
        from ib_users.interactors.storages.otp_verification_storage import \
            OTPVerificationStorage
        country_code = "+91"
        phone_number = "9866123399"
        phone_number_dto = PhoneNumberDTO(
            country_code=country_code,
            phone_number=phone_number
        )
        email = "tdd@testing.com"
        user_id = "1"
        otp_verification_storage_mock = create_autospec(OTPVerificationStorage)
        otp_blacklist_storage_mock = create_autospec(OTPBlacklistStorage)
        sms_sender_mock = create_autospec(SMSSender)
        call_service_mock = create_autospec(CallService)
        email_sender_mock = create_autospec(EmailSender)
        phone_number_validator_mock = create_autospec(PhoneNumberValidator)
        email_validator_mock = create_autospec(EmailValidator)

        generate_otp_value = "123456"

        def generate_otp_mock():
            return generate_otp_value
        BaseOTPVerificationInteractor._generate_otp = generate_otp_mock

        return phone_number_dto,  email, user_id, otp_blacklist_storage_mock, \
               otp_verification_storage_mock, sms_sender_mock, \
               call_service_mock, email_sender_mock, \
               phone_number_validator_mock, email_validator_mock

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL.value,
        SendOTPThrough.SMS.value
    ])
    @pytest.mark.parametrize("otp_status", [
        OTPStatus.NOT_REQUESTED,
        OTPStatus.EXPIRED
    ])
    def test_verify_user(self, setup,
                         verification_type_mock: VerificationType,
                         send_otp_through: SendOTPThrough,
                         otp_status: OTPStatus):

        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock, \
        phone_number_validator_mock, email_validator_mock = setup
        generate_otp_value = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )
        otp_verification_storage_mock.get_otp_status_by_user_id.return_value \
            = otp_status
        otp_blacklist_storage_mock.is_phone_number_blacklisted.\
            return_value = False
        otp_blacklist_storage_mock.is_email_blacklisted. \
            return_value = False

        user_otp_verification_interactor.verify_user(
            phone_number_dto=phone_number_dto,
            send_otp_through=send_otp_through,
            sms_sender=sms_sender_mock,
            call_service=call_service_mock,
            email=email,
            email_sender=email_sender_mock,
            user_id=user_id
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.\
            assert_called_once_with(
                phone_number_dto=phone_number_dto
            )
        otp_blacklist_storage_mock.is_email_blacklisted. \
            assert_called_once_with(
                email=email
            )

        otp_verification_storage_mock.get_otp_status_by_user_id.\
            assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )
        if otp_status == OTPStatus.NOT_REQUESTED:
            otp_verification_storage_mock.create_otp_verification_by_user_id. \
                assert_called_once_with(
                    user_id=user_id,
                    otp=generate_otp_value,
                    expiry_time_in_sec=expiry_time_in_sec,
                    verification_type=verification_type_mock
                )
        elif otp_status == OTPStatus.EXPIRED:
            otp_verification_storage_mock.update_otp_details_by_user_id. \
                assert_called_once_with(
                    user_id=user_id,
                    otp=generate_otp_value,
                    expiry_time_in_sec=expiry_time_in_sec,
                    verification_type=verification_type_mock
                )

        email_sender_mock.send_otp.assert_called_once_with(
            email=email,
            otp=generate_otp_value
        )
        if send_otp_through == SendOTPThrough.CALL.value:
            sms_sender_mock.send_otp(
                country_code=phone_number_dto.country_code,
                phone_number=phone_number_dto.phone_number,
                otp=generate_otp_value
            )
        elif send_otp_through == SendOTPThrough.SMS.value:
            call_service_mock.request_call(
                country_code=phone_number_dto.country_code,
                phone_number=phone_number_dto.phone_number,
                otp=generate_otp_value
            )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL.value,
        SendOTPThrough.SMS.value
    ])
    def test_verify_user_when_prev_otp_is_not_expired(self, setup,
                                    send_otp_through: SendOTPThrough,
                                    verification_type_mock: VerificationType):
        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock, \
        phone_number_validator_mock, email_validator_mock = setup
        generate_otp_value = "123456"
        expiry_time_in_sec = OTP_EXPIRY_TIME_IN_SEC
        otp_status = OTPStatus.ACTIVE
        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )
        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            return_value = False
        otp_blacklist_storage_mock.is_email_blacklisted. \
            return_value = False

        otp_verification_storage_mock.get_otp_status_by_user_id.return_value \
            = otp_status
        otp_verification_storage_mock.get_otp_details_by_user_id.return_value \
            = GetOTPDetailsDTO(
                otp=generate_otp_value
            )
        user_otp_verification_interactor.verify_user(
            phone_number_dto=phone_number_dto,
            send_otp_through=send_otp_through,
            sms_sender=sms_sender_mock,
            call_service=call_service_mock,
            email=email,
            email_sender=email_sender_mock,
            user_id=user_id
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            assert_called_once_with(
            phone_number_dto=phone_number_dto
        )
        otp_blacklist_storage_mock.is_email_blacklisted. \
            assert_called_once_with(
            email=email
        )

        otp_verification_storage_mock.get_otp_status_by_user_id.\
            assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )
        otp_verification_storage_mock.get_otp_details_by_user_id. \
            assert_called_once_with(
            user_id=user_id,
            verification_type=verification_type_mock
        )
        otp_verification_storage_mock.update_otp_details_by_user_id.\
            assert_called_once_with(
                user_id=user_id,
                otp=generate_otp_value,
                expiry_time_in_sec=expiry_time_in_sec,
                verification_type=verification_type_mock
            )

        email_sender_mock.send_otp.assert_called_once_with(
            email=email,
            otp=generate_otp_value
        )
        if send_otp_through == SendOTPThrough.CALL.value:
            sms_sender_mock.send_otp(
                country_code=phone_number_dto.country_code,
                phone_number=phone_number_dto.phone_number,
                otp=generate_otp_value
            )
        elif send_otp_through == SendOTPThrough.SMS.value:
            call_service_mock.request_call(
                country_code=phone_number_dto.country_code,
                phone_number=phone_number_dto.phone_number,
                otp=generate_otp_value
            )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL.value,
        SendOTPThrough.SMS.value
    ])
    def test_verify_user_when_phone_number_is_black_listed(self,
                                   setup,
                                   verification_type_mock: VerificationType,
                                   send_otp_through: SendOTPThrough):

        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock, \
        phone_number_validator_mock, email_validator_mock = setup

        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.return_value \
            = True
        otp_blacklist_storage_mock.is_email_blacklisted.return_value = False

        with pytest.raises(PhoneNumberIsBlackListedException) as e:
            user_otp_verification_interactor.verify_user(
                phone_number_dto=phone_number_dto,
                send_otp_through=send_otp_through,
                sms_sender=sms_sender_mock,
                call_service=call_service_mock,
                email=email,
                email_sender=email_sender_mock,
                user_id=user_id
            )

        otp_blacklist_storage_mock.is_phone_number_blacklisted. \
            assert_called_once_with(
                phone_number_dto=phone_number_dto
            )

        assert ExceptionMessage.GIVEN_PHONE_NUMBER_IS_BLACK_LISTED \
               in str(e.value)

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.LOGIN_WITH_OTP.value
    ])
    @pytest.mark.parametrize('send_otp_through', [
        SendOTPThrough.CALL.value,
        SendOTPThrough.SMS.value
    ])
    def test_verify_user_when_email_is_black_listed(self,
                               setup,
                               verification_type_mock: VerificationType,
                               send_otp_through: SendOTPThrough):

        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock, \
        phone_number_validator_mock, email_validator_mock = setup

        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        otp_blacklist_storage_mock.is_phone_number_blacklisted.return_value \
            = False
        otp_blacklist_storage_mock.is_email_blacklisted.return_value = True

        with pytest.raises(EmailIsBlackListedException) as e:
            user_otp_verification_interactor.verify_user(
                phone_number_dto=phone_number_dto,
                send_otp_through=send_otp_through,
                sms_sender=sms_sender_mock,
                call_service=call_service_mock,
                email=email,
                email_sender=email_sender_mock,
                user_id=user_id
            )

        otp_blacklist_storage_mock.is_email_blacklisted. \
            assert_called_once_with(
                email=email
            )

        assert ExceptionMessage.GIVEN_EMAIL_IS_BLACK_LISTED \
               in str(e.value)
