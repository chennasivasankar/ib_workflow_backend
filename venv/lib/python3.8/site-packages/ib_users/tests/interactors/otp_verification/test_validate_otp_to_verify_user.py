import pytest
from mock import create_autospec

from ib_users.constants.otp_verification_constants import OTPStatus
from ib_users.exceptions.otp_verification_exceptions import ExceptionMessage, \
    OTPExpiredException, InvalidOTPException, MaxRetriesExceededException

from ib_users.constants.otp_verification_constants import VerificationType
from ib_users.interactors.storages.otp_blacklist_storage import \
    OTPBlacklistStorage
from ib_users.interactors.third_party.call_service import CallService
from ib_users.interactors.third_party.email_sender import EmailSender
from ib_users.interactors.third_party.sms_sender import SMSSender
from ib_users.interactors.user_otp_verification_interactor import \
    UserOTPVerificationInteractor
from ib_users.utils.dtos import PhoneNumberDTO


class TestValidateOTPToVerifyUser:
    @pytest.fixture
    def setup(self):
        from ib_users.interactors.storages.otp_verification_storage import \
            OTPVerificationStorage
        country_code = "+91"
        phone_number = "9866123399"
        phone_number_dto = PhoneNumberDTO(
            country_code=country_code,
            phone_number=phone_number
        )
        email = "tdd@testing.com"
        user_id = "1"
        otp_verification_storage_mock = create_autospec(OTPVerificationStorage)
        otp_blacklist_storage_mock = create_autospec(OTPBlacklistStorage)
        sms_sender_mock = create_autospec(SMSSender)
        call_service_mock = create_autospec(CallService)
        email_sender_mock = create_autospec(EmailSender)

        return phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
               otp_verification_storage_mock, sms_sender_mock, \
               call_service_mock, email_sender_mock

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    def test_validate_otp_to_verify_user(self, setup,
                        verification_type_mock: VerificationType):
        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock = setup

        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )
        otp_to_be_verified = "123456"
        otp_verification_storage_mock.\
            is_exceeded_max_retries_count_for_user_id.return_value = False

        is_verified =user_otp_verification_interactor.validate_otp_to_verify_user(
            user_id=user_id,
            otp_to_be_verified=otp_to_be_verified
        )

        otp_verification_storage_mock.is_otp_matched_for_user_id.\
            assert_called_once_with(
                user_id=user_id,
                otp_to_be_verified=otp_to_be_verified,
                verification_type=verification_type_mock
            )

        otp_verification_storage_mock.get_otp_status_by_user_id.\
            assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )

        otp_verification_storage_mock.\
            is_exceeded_max_retries_count_for_user_id.assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )

        otp_verification_storage_mock.reset_retries_count_for_user_id. \
            assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )
        
        assert is_verified

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    def test_validate_otp_to_verify_user_when_otp_expired(self, setup,
                                  verification_type_mock: VerificationType):
        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock = setup

        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )
        otp_to_be_verified = "123456"
        otp_verification_storage_mock. \
            is_exceeded_max_retries_count_for_user_id.return_value = False
        otp_verification_storage_mock.get_otp_status_by_user_id.return_value \
            = OTPStatus.EXPIRED

        with pytest.raises(OTPExpiredException) as e:
            user_otp_verification_interactor.validate_otp_to_verify_user(
                user_id=user_id,
                otp_to_be_verified=otp_to_be_verified
            )

        assert ExceptionMessage.OTP_IS_EXPIRED in str(e.value)

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    def test_validate_otp_to_verify_user_when_otp_is_invalid(self, setup,
                                verification_type_mock: VerificationType):
        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock = setup
        otp_to_be_verified = "123456"
        otp_verification_storage_mock.\
            is_exceeded_max_retries_count_for_user_id.return_value = False
        otp_verification_storage_mock.is_otp_matched_for_user_id.return_value \
            = False

        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        with pytest.raises(InvalidOTPException) as e:
            user_otp_verification_interactor.validate_otp_to_verify_user(
                user_id=user_id,
                otp_to_be_verified=otp_to_be_verified
            )
        assert ExceptionMessage.ENTER_A_VALID_OTP in str(e.value)
        otp_verification_storage_mock.\
            increase_retries_count_by_one_for_user_id.assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )

    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    def test_verify_phone_number_when_max_retries_exceeded(self, setup,
                                   verification_type_mock: VerificationType):
        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock = setup
        otp_to_be_verified = "123456"
        otp_verification_storage_mock. \
            is_exceeded_max_retries_count_for_user_id.return_value = False
        otp_verification_storage_mock.is_otp_matched_for_user_id.return_value \
            = True
        otp_verification_storage_mock.\
            is_exceeded_max_retries_count_for_user_id.return_value = True

        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        with pytest.raises(MaxRetriesExceededException) as e:
            user_otp_verification_interactor.validate_otp_to_verify_user(
                user_id=user_id,
                otp_to_be_verified=otp_to_be_verified
            )
        assert ExceptionMessage.RETRY_AFTER_X_DURATION in str(e.value)

        otp_verification_storage_mock.\
            is_exceeded_max_retries_count_for_user_id.assert_called_once_with(
                user_id=user_id,
                verification_type=verification_type_mock
            )

    @pytest.mark.parametrize('otp_to_be_verified,exception_message', [
        ("   ", ExceptionMessage.OTP_IS_EMPTY),
        ("123", ExceptionMessage.OTP_SHOULD_CONTAIN_X_DIGITS),
        ("abc123", ExceptionMessage.OTP_SHOULD_CONTAIN_ONLY_NUMBERS)
    ])
    @pytest.mark.parametrize("verification_type_mock", [
        VerificationType.VERIFY_PHONE_NUMBER_WITH_OTP.value,
        VerificationType.VERIFY_EMAIL_WITH_OTP.value,
        VerificationType.REGISTRATION_WITH_OTP.value,
        VerificationType.RESET_PASSWORD_WITH_OTP.value
    ])
    def test_validate_otp_to_verify_user_when_otp_is_invalid(self, setup,
                                 otp_to_be_verified: str,
                                 exception_message: str,
                                 verification_type_mock: VerificationType):
        phone_number_dto, email, user_id, otp_blacklist_storage_mock, \
        otp_verification_storage_mock, sms_sender_mock, \
        call_service_mock, email_sender_mock = setup
        otp_verification_storage_mock. \
            is_exceeded_max_retries_count_for_user_id.return_value = False
        user_otp_verification_interactor = UserOTPVerificationInteractor(
            storage=otp_verification_storage_mock,
            otp_blacklist_storage=otp_blacklist_storage_mock,
            verification_type=verification_type_mock
        )

        with pytest.raises(InvalidOTPException) as e:
            user_otp_verification_interactor.validate_otp_to_verify_user(
                user_id=user_id,
                otp_to_be_verified=otp_to_be_verified
            )

        assert exception_message in str(e.value)