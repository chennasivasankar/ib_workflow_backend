import uuid

import pytest

from ib_users.exceptions.custom_exception_constants import \
    DEVICE_ID_DOES_NOT_EXIST, USER_NOT_MAPPED_TO_DEVICE, \
    ACCESS_TOKEN_NOT_MAPPED_TO_DEVICE
from ib_users.interactors.storages.user_login_device_details_storage import \
    UserDeviceLoginDTO
from ib_users.models import UserAccount
from ib_users.storages.user_login_device_details_sql_storage import \
    UserLoginDeviceDetailsSQLStorage
from ib_users.tests.storages.test_user_account_storage import \
    UserAccountCreationForTestCases
from ib_users.utils.tests_utils import TestsUtils
from ib_users.validators.base_validator import CustomException


class TestUserLogoutFromDevices:

    @pytest.mark.django_db
    def test_get_access_token_when_device_does_not_exist(self):
        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_logout_dto = UserDeviceLoginDTO(
            str(uuid.uuid4()),
            "device_id",
            "access_token")
        with pytest.raises(CustomException) as invalid_exception:
            user_accounts_sql_storage.check_if_given_login_device_details_mapping_exists \
                (user_logout_dto)
        TestsUtils.assert_custom_exception(DEVICE_ID_DOES_NOT_EXIST,
                                           invalid_exception)

    @pytest.mark.django_db
    def test_get_access_token_when_user_is_not_mapped(self):
        from ib_users.models import UserLoginDeviceDetails

        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()

        device_id = "device_id"
        user_account = UserAccountCreationForTestCases.create_user_with_username(
            username="username",
            password="password$%^")
        access_token = "access_token"
        UserLoginDeviceDetails.objects.create(device_id=device_id,
                                              user_account=user_account,
                                              access_token=access_token)

        user_logout_dto = UserDeviceLoginDTO(str(uuid.uuid4()),
                                             device_id,
                                             access_token)
        with pytest.raises(CustomException) as invalid_exception:
            user_accounts_sql_storage.check_if_given_login_device_details_mapping_exists \
                (user_logout_dto)
        TestsUtils.assert_custom_exception(USER_NOT_MAPPED_TO_DEVICE,
                                           invalid_exception)

    @pytest.mark.django_db
    def test_get_access_token_when_device_id_and_access_token_not_mapped(self):
        from ib_users.models import UserLoginDeviceDetails

        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()

        device_id = "device_id"
        user_account = UserAccountCreationForTestCases.create_user_with_username(
            username="username",
            password="password$%^")
        access_token = "access_token"
        UserLoginDeviceDetails.objects.create(device_id=device_id,
                                              user_account=user_account,
                                              access_token=access_token)

        user_logout_dto = UserDeviceLoginDTO(user_account.user_id,
                                             device_id,
                                             "wrong_access_token")
        with pytest.raises(CustomException) as invalid_exception:
            user_accounts_sql_storage.check_if_given_login_device_details_mapping_exists \
                (user_logout_dto)
        TestsUtils.assert_custom_exception(ACCESS_TOKEN_NOT_MAPPED_TO_DEVICE,
                                           invalid_exception)

    @pytest.mark.django_db
    def test_get_access_token_with_correct_device_id_and_user_id(self):
        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_id_and_device_id_dto = self._create_user_login_device_and_get_dto()
        user_accounts_sql_storage.check_if_given_login_device_details_mapping_exists \
            (user_id_and_device_id_dto)

    @pytest.mark.django_db
    def test_remove_given_user_and_device_mapping(self):
        from ib_users.models import UserLoginDeviceDetails

        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_id_and_device_id_dto = self._create_user_login_device_and_get_dto()

        user_accounts_sql_storage.remove_given_user_and_device_mapping(
            user_id_and_device_id_dto)

        user_login_device_objs = UserLoginDeviceDetails.objects.filter(
            user_account__user_id=user_id_and_device_id_dto.user_id,
            device_id=user_id_and_device_id_dto.device_id)
        assert user_login_device_objs.count() == 0

    @pytest.mark.django_db
    def test_get_access_tokens_of_all_login_devices_for_mapped_user(self):
        from ib_users.models import UserLoginDeviceDetails
        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()

        user_account = UserAccountCreationForTestCases.create_user_with_username(
            username="username",
            password="password$%^")

        access_token = "access_token_1"
        device_id = "device_1"
        UserLoginDeviceDetails.objects.create(device_id=device_id,
                                              user_account=user_account,
                                              access_token=access_token)

        user_login_data = user_accounts_sql_storage.get_all_devices_login_details_of_given_user(
            user_account.user_id)

        for item in user_login_data:
            assert item.device_id == device_id
            assert item.access_token == access_token

    @pytest.mark.django_db
    def test_get_access_tokens_of_all_login_devices_for_not_mapped_user(self):
        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()

        assert user_accounts_sql_storage.get_all_devices_login_details_of_given_user(
            uuid.uuid4()) == []

    @pytest.mark.django_db
    def test_remove_all_device_login_details_of_given_user(self):
        from ib_users.models import UserLoginDeviceDetails

        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_id_and_device_id_dto = self._create_user_login_device_and_get_dto()

        user_accounts_sql_storage.remove_all_device_login_details_of_given_user(
            user_id_and_device_id_dto.user_id)

        assert UserLoginDeviceDetails.objects.filter(
            user_account__user_id=user_id_and_device_id_dto.user_id).exists() == False

    @pytest.mark.django_db
    def test_remove_device_login_details_of_user_except_of_given_access_tokens(
            self):
        from ib_users.models import UserLoginDeviceDetails

        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_id_and_device_id_dto = self._create_user_login_device_and_get_dto()

        except_access_token = "except_access_token"
        UserLoginDeviceDetails.objects.create(device_id="device_id2",
                                              user_account_id=user_id_and_device_id_dto.user_id,
                                              access_token=except_access_token)

        user_accounts_sql_storage.remove_device_login_details_of_user_except_of_given_access_tokens(
            user_id=user_id_and_device_id_dto.user_id,
            access_tokens=[except_access_token])

        login_device_details = UserLoginDeviceDetails.objects.filter(
            user_account__user_id=user_id_and_device_id_dto.user_id)
        assert login_device_details.count() == 1
        assert login_device_details[0].access_token == except_access_token

    @pytest.mark.django_db
    def test_update_access_token_in_access_token_and_device_id_map(self):
        from ib_users.models import UserLoginDeviceDetails

        user_account = UserAccountCreationForTestCases.create_user_with_username(
            username="username",
            password="password$%^")
        old_access_token = "old_access_token"
        new_access_token = "new_access_token"
        user_login_device_details_obj = UserLoginDeviceDetails.objects.create(
            device_id="device_id",
            user_account=user_account,
            access_token=old_access_token)

        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_accounts_sql_storage.update_access_token_in_access_token_and_device_id_map(
            old_access_token=old_access_token,
            new_access_token=new_access_token
        )
        updated_user_login_device_details_obj = UserLoginDeviceDetails.objects.get(
            id=user_login_device_details_obj.id)
        assert updated_user_login_device_details_obj.access_token == new_access_token

    @pytest.mark.django_db
    def test_create_given_login_device_mapping_in_storage(self):
        from ib_users.models import UserLoginDeviceDetails
        user_accounts_sql_storage = UserLoginDeviceDetailsSQLStorage()
        user_account = UserAccount.objects.create(username="username34",
                                                  password="password#$%")
        user_device_login_dto = UserDeviceLoginDTO(
            user_id=user_account.user_id,
            device_id="device_id",
            access_token="access_token"
        )
        user_accounts_sql_storage.create_given_login_device_mapping_in_storage(
            user_device_login_dto)
        UserLoginDeviceDetails.objects.filter(
            user_account__user_id=user_device_login_dto.user_id,
            device_id=user_device_login_dto.device_id,
            access_token=user_device_login_dto.access_token).exists()

    @staticmethod
    def _create_user_login_device_and_get_dto():
        from ib_users.models import UserLoginDeviceDetails

        device_id = "device_id"
        user_account = UserAccountCreationForTestCases.create_user_with_username(
            username="username",
            password="password$%^")
        access_token = "access_token"
        UserLoginDeviceDetails.objects.create(device_id=device_id,
                                              user_account=user_account,
                                              access_token=access_token)
        user_logout_dto = UserDeviceLoginDTO(user_account.user_id,
                                             device_id,
                                             access_token)
        return user_logout_dto
